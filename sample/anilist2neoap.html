<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>anilist2neoapo</title>
  <style>
    /* Reset and Base Styles */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      /* Removed max-width */
      margin: 0 auto;
      padding: 20px;
      background-color: #d1dce3; /* Updated background */
      color: #333;
      line-height: 1.6;
      display: flex; /* Added for centering containers */
      flex-direction: column; /* Added for centering containers */
      align-items: center; /* Added for centering containers */
    }

    /* Headings */
    h1, h2 {
      text-align: center;
      color: #2e51a2;
      margin-bottom: 30px;
      font-weight: 700;
      position: relative;
      padding-bottom: 10px;
      width: 100%; /* Ensure headings take width */
    }
    h1::after, h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 3px;
      background-color: #2e51a2;
      border-radius: 3px;
    }

    /* --- NEW Anime List Layout Styles --- */
     #anime-list {
         width: 100%; /* Allow list container to take width */
         display: flex;
         flex-direction: column;
         align-items: center; /* Center the cards */
         gap: 20px; /* Space between cards */
     }

     .container {
         border: 1px solid #ccc;
         /* margin-bottom: 20px; Removed, using gap now */
         padding: 15px; /* Slightly increased padding */
         display: flex;
         align-items: flex-start;
         background-color: #fff; /* Container background */
         width: 600px; /* Fixed width */
         max-width: 95%; /* Add max-width for smaller screens */
         box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1); /* Softened shadow */
         border-radius: 8px; /* Rounded corners */
         box-sizing: border-box; /* Include padding/border in width */
     }
     .container img.list-thumbnail { /* Specific class for list thumbnail */
         margin-right: 20px;
         width: 100px; /* Thumbnail width */
         height: 140px; /* Thumbnail height */
         object-fit: cover;
         border: 1px solid #ddd;
         border-radius: 4px; /* Rounded corners for image */
         flex-shrink: 0; /* Prevent image shrinking */
     }
     .details {
         flex-grow: 1;
         min-width: 0; /* Allow details section to shrink if needed */
     }
     .details h2.anime-title { /* Specific class for title */
         margin-top: 0;
         margin-bottom: 10px;
         font-size: 1.2em;
         color: #3f51b5; /* Match title link color */
         cursor: pointer;
         transition: color 0.2s;
         line-height: 1.3; /* Adjust line height */
         text-align: left; /* Align title left */
         padding-bottom: 0; /* Remove heading underline */
         position: static; /* Remove relative positioning */
     }
     .details h2.anime-title::after {
        content: none; /* Remove heading underline */
     }
     .details h2.anime-title:hover {
        color: #303f9f;
        text-decoration: underline;
     }
     .details table.info-table { /* Specific class for info table */
         border-collapse: collapse;
         width: 100%;
         margin-bottom: 10px;
         font-size: 0.9em;
     }
     /* --- MODIFIED for vertical layout --- */
     .details table.info-table th,
     .details table.info-table td {
         border: 1px solid #eee; /* Lighter border */
         padding: 6px 8px; /* Adjusted padding */
         text-align: left;
         vertical-align: middle; /* Align vertically */
         word-break: break-word; /* Allow wrapping */
     }
     .details table.info-table th {
         background-color: #f8f9fa; /* Lighter background */
         width: 80px; /* Keep width for consistency */
         font-weight: 600; /* Bolder header */
         color: #555; /* Header text color */
     }
     /* --- END MODIFIED --- */
     .details table.info-table td.neoapo-value-cell span.placeholder { /* Style for placeholder */
         color: #999;
         font-style: italic;
     }
     .button-container {
         margin-top: 15px; /* Increased top margin */
         display: flex;
         flex-wrap: wrap; /* Allow buttons to wrap on small screens */
         gap: 10px;
         /* position: relative; Removed */
     }
     .search-button, .unregister-button {
         padding: 6px 12px; /* Adjusted padding */
         color: white;
         border: none;
         border-radius: 4px;
         cursor: pointer;
         font-size: 0.9em;
         transition: background-color 0.2s;
     }
     .search-button {
         background-color: #4CAF50; /* Green */
     }
     .search-button:hover:not(:disabled) { /* Add :not(:disabled) */
         background-color: #45a049;
     }
     .search-button:disabled {
         background-color: #cccccc;
         cursor: not-allowed;
     }
     .unregister-button {
         background-color: #007bff; /* Blue */
     }
     .unregister-button:hover:not(:disabled):not(.registered) { /* Adjusted hover */
         background-color: #0056b3;
     }
     .unregister-button.registered {
         background-color: #6c757d; /* Grey */
         cursor: default;
     }
     .unregister-button.registered:hover {
         background-color: #6c757d; /* No hover change */
     }
     /* --- NEW Style for search result title --- */
     .search-result-title {
        margin-top: 8px; /* Space below button */
        padding: 5px 8px;
        background-color: #e9f5e9;
        border: 1px solid #a5d6a7;
        border-radius: 4px;
        font-size: 0.9em;
        cursor: pointer;
        display: inline-block; /* Make it wrap nicely */
        transition: background-color 0.2s;
        /* Position under the button container */
        width: calc(100% - 16px); /* Adjust width as needed */
        box-sizing: border-box;
     }
     .search-result-title:hover {
         background-color: #c8e6c9;
     }
    /* --- END NEW Anime List Layout Styles --- */


    /* Loading and Error States */
    .loading, .error {
      text-align: center;
      padding: 30px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      font-style: italic;
      color: #666;
      width: 600px; /* Match container width */
      max-width: 95%;
      box-sizing: border-box;
    }
    .error {
      color: #e53935;
      background-color: #ffebee;
      font-style: normal;
    }

    /* Links (General) */
    .title-link { /* Used in details view */
      cursor: pointer;
      color: #3f51b5;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.2s;
    }
    .title-link:hover {
      color: #303f9f;
      text-decoration: underline;
    }

    /* Dialog Styles */
    .dialog-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .dialog-content {
      background-color: white;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
      max-width: 400px;
      width: 90%;
    }
    .dialog-title {
      font-size: 1.3em;
      font-weight: 600;
      margin-bottom: 15px;
      color: #2e51a2;
    }
    .dialog-buttons {
      display: flex;
      justify-content: flex-end;
      margin-top: 25px;
      gap: 10px;
    }
    .dialog-button {
      padding: 10px 18px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s, box-shadow 0.2s;
    }
    .dialog-button-primary {
      background-color: #2e51a2;
      color: white;
    }
    .dialog-button-primary:hover {
      background-color: #1f3c7a;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .dialog-button-secondary {
      background-color: #e0e0e0;
      color: #333;
    }
     .dialog-button-secondary:hover {
      background-color: #bdbdbd;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* Detail View Styles */
    #anime-details { /* Container for detail view */
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        width: 100%; /* Take available width */
        max-width: 1100px; /* Restore max-width for details */
        box-sizing: border-box;
        margin-top: 20px; /* Add margin when shown */
    }
    .back-button-container {
        margin-bottom: 25px;
    }
    #back-button {
      background-color: #6c757d; /* Grey */
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    #back-button:hover {
      background-color: #5a6268;
    }
    .detail-table { /* Table within the details view */
      margin-top: 20px;
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      overflow: hidden;
      table-layout: auto; /* Let table adjust columns */
    }
    .detail-table thead th {
      background-color: #2e51a2;
      color: white;
      padding: 12px 15px;
      text-align: left;
      font-weight: 600;
    }
    .detail-table th { /* Label column */
      width: 180px;
      background-color: #e8eaf6;
      color: #303f9f;
      text-align: left;
      font-weight: 600;
      padding: 12px 15px;
      border-bottom: 1px solid #eee;
    }
    .detail-table td { /* Value column */
      word-break: break-word;
      background-color: #ffffff;
      padding: 12px 15px;
      border-bottom: 1px solid #eee;
    }
     .detail-table tr:last-child th,
     .detail-table tr:last-child td {
         border-bottom: none;
     }
    .api-path-column {
      width: 180px;
      font-family: 'Consolas', 'Menlo', monospace;
      color: #555;
      font-size: 0.85em;
      background-color: #f8f9fa !important;
      padding: 12px 10px !important;
      vertical-align: top;
      border-right: 1px solid #eee;
       border-bottom: 1px solid #eee;
    }
     .detail-table tr:last-child .api-path-column {
         border-bottom: none;
     }
    .cover-image {
      width: 100%;
      max-width: 250px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      margin-bottom: 20px;
      display: block;
    }
    .cover-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 25px;
    }
    .anime-info-container {
      display: flex;
      flex-wrap: wrap;
      gap: 30px;
      margin-top: 20px;
    }
    .anime-info-left {
      flex: 0 0 250px;
      display: flex;
      justify-content: center;
    }
    .anime-info-right {
      flex: 1;
      min-width: 300px;
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
      .container {
        width: 90%; /* More width on tablets */
      }
      .detail-table th { width: 150px; }
      .api-path-column { width: 150px; }
      .anime-info-container {
        flex-direction: column;
        gap: 20px;
      }
      .anime-info-left, .anime-info-right {
        width: 100%;
        flex: none;
      }
      .cover-image { max-width: 200px; }
    }

     @media (max-width: 650px) {
         .container {
             flex-direction: column; /* Stack image and details */
             align-items: center; /* Center items when stacked */
             width: 95%;
         }
         .container img.list-thumbnail {
             margin-right: 0;
             margin-bottom: 15px; /* Add space below image */
             width: 150px; /* Make image slightly larger */
             height: 210px;
         }
         .details {
             width: 100%; /* Take full width when stacked */
         }
          .details h2.anime-title {
             text-align: center; /* Center title when stacked */
         }
         .details table.info-table th { width: 70px; } /* Adjust table header width */
     }

     @media (max-width: 480px) {
         body { padding: 10px; }
         h1 { font-size: 1.5em; }
         h2 { font-size: 1.3em; } /* Applies to detail title too */
         .container { padding: 10px; }
         .container img.list-thumbnail {
             width: 120px;
             height: 168px;
         }
         .details h2.anime-title { font-size: 1.1em; }
         .details table.info-table { font-size: 0.85em; }
          .details table.info-table th,
          .details table.info-table td { padding: 5px 6px; }

         .button-container { justify-content: center; } /* Center buttons */
         .search-button, .unregister-button { font-size: 0.85em; padding: 5px 10px; }
          /* Make search result wrap under button */
          .search-result-title {
             width: 100%; /* Full width relative to details div */
             text-align: center;
             margin-left: 0; /* Ensure it doesn't indent */
             margin-right: 0;
             padding-left: 8px;
             padding-right: 8px;
          }

         /* Detail view on small screens */
         #anime-details { padding: 15px; }
         .detail-table { font-size: 0.9em; }
         .detail-table th, .detail-table td, .api-path-column { padding: 8px 10px; }
         .detail-table th { width: 100px; }
         .api-path-column { width: 100px; }
         #back-button { padding: 8px 15px; font-size: 0.9em;}
     }
  </style>
</head>
<body>
  <h1>anilist2neoapo</h1>

  <div id="anime-list">
    <p class="loading">データを読み込み中...</p>
    </div>

  <div id="anime-details" style="display: none;">
    <!-- Detail view structure remains the same -->
    <div class="back-button-container">
      <button id="back-button">← 一覧に戻る</button>
    </div>
    <h2 id="detail-title"></h2>
    <div id="detail-content">
      </div>
  </div>

  <div id="registration-dialog" style="display: none;" class="dialog-overlay">
    <!-- Dialog structure remains the same -->
    <div class="dialog-content">
      <div class="dialog-title">登録確認</div>
      <p><strong id="dialog-anime-title"></strong> をneoapoに新規登録しますか？</p>
      <div class="dialog-buttons">
        <button id="dialog-cancel" class="dialog-button dialog-button-secondary">キャンセル</button>
        <button id="dialog-confirm" class="dialog-button dialog-button-primary">はい</button>
      </div>
    </div>
  </div>

  <script>
    // --- Configuration ---
    const ANILIST_API_URL = 'https://graphql.anilist.co';
    const ITEMS_PER_PAGE = 20;

    // --- DOM Elements ---
    const animeListContainer = document.getElementById('anime-list');
    const animeDetailsContainer = document.getElementById('anime-details');
    const detailTitleElement = document.getElementById('detail-title');
    const detailContentElement = document.getElementById('detail-content');
    const backButton = document.getElementById('back-button');
    const registrationDialog = document.getElementById('registration-dialog');
    const dialogAnimeTitle = document.getElementById('dialog-anime-title');
    const dialogConfirmButton = document.getElementById('dialog-confirm');
    const dialogCancelButton = document.getElementById('dialog-cancel');

    // --- State ---
    let currentAnimeIdForDialog = null;
    let currentAnimeTitleForDialog = null;
    let animeDataCache = {};

    // --- Helper Functions (Formatting, etc.) ---
    function formatDate(dateInput) {
      if (!dateInput) return '-';
      try {
        const year = dateInput.year;
        const month = dateInput.month;
        const day = dateInput.day;

        if (year && month && day) {
             const date = new Date(year, month - 1, day);
             if (isNaN(date.getTime())) return '-';
             return `${year}/${String(month).padStart(2, '0')}/${String(day).padStart(2, '0')}`;
        } else if (year && month) {
             return `${year}/${String(month).padStart(2, '0')}/??`;
        } else if (year) {
             return `${year}/??/??`;
        } else if (typeof dateInput === 'number') {
             const date = new Date(dateInput * 1000);
             if (isNaN(date.getTime())) return '-';
             const y = date.getFullYear();
             const m = String(date.getMonth() + 1).padStart(2, '0');
             const d = String(date.getDate()).padStart(2, '0');
             return `${y}/${m}/${d}`;
        }
        return '-';
      } catch (e) {
        console.error("Error formatting date:", dateInput, e);
        return '-';
      }
    }

    function formatDateTime(timestamp) {
        if (!timestamp) return '-';
        try {
            const date = new Date(timestamp * 1000);
            if (isNaN(date.getTime())) return '-';
            return date.toLocaleString('ja-JP', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit'
            });
        } catch (e) {
            console.error("Error formatting datetime:", timestamp, e);
            return '-';
        }
    }

    function mapFormat(formatCode) {
        if (!formatCode) return '-';
        const formatMap = {
            TV: 'TVアニメ', MOVIE: '映画', OVA: 'OVA', ONA: 'ONA',
            SPECIAL: 'スペシャル', MUSIC: 'ミュージック', MANGA: 'マンガ',
            NOVEL: '小説', ONE_SHOT: 'ワンショット'
        };
        return formatMap[formatCode] || formatCode;
    }

     function mapStatus(statusCode) {
        if (!statusCode) return '-';
        const statusMap = {
            FINISHED: '完結', RELEASING: '放送中',
            NOT_YET_RELEASED: '未放送', CANCELLED: '中止', HIATUS: '休止中'
        };
        return statusMap[statusCode] || statusCode;
    }

     function mapSeason(seasonCode) {
        if (!seasonCode) return '-';
        const seasonMap = { WINTER: '冬', SPRING: '春', SUMMER: '夏', FALL: '秋' };
        return seasonMap[seasonCode] || seasonCode;
     }

     function mapSource(sourceCode) {
        if (!sourceCode) return '-';
        const sourceMap = {
            ORIGINAL: 'オリジナル', MANGA: '漫画', LIGHT_NOVEL: 'ライトノベル',
            VISUAL_NOVEL: 'ビジュアルノベル', VIDEO_GAME: 'ビデオゲーム', OTHER: 'その他',
            NOVEL: '小説', DOUJINSHI: '同人誌', ANIME: 'アニメ',
            WEB_NOVEL: 'ウェブ小説', LIVE_ACTION: '実写', GAME: 'ゲーム',
            COMIC: 'コミック', MULTIMEDIA_PROJECT: 'メディアミックス', PICTURE_BOOK: '絵本'
        };
        return sourceMap[sourceCode] || sourceCode;
     }

     /**
      * Finds the container for a given anime ID and marks its
      * 'Unregister' button as registered (updates text, class, disabled state, removes listener).
      * Also inserts the title into the neoapo cell if provided.
      * @param {string|number} animeId The ID of the anime to mark as registered.
      * @param {string} [titleToInsert] Optional: Title to insert into the neoapo cell if not already done.
      */
     function markAsRegistered(animeId, titleToInsert = null) {
         if (!animeId) {
             console.warn("markAsRegistered called with invalid animeId:", animeId);
             return;
         }

         const targetContainer = animeListContainer.querySelector(`.container[data-anime-id="${animeId}"]`);
         if (!targetContainer) {
             console.warn(`Could not find container for ID: ${animeId} in markAsRegistered`);
             return;
         }

         // Optional: Insert title if provided (useful for confirm dialog path)
         if (titleToInsert) {
             const neoapoValueCell = targetContainer.querySelector('.neoapo-value-cell');
             if (neoapoValueCell) {
                 neoapoValueCell.innerHTML = ''; // Clear placeholder
                 neoapoValueCell.textContent = titleToInsert;
             } else {
                  console.warn(`Could not find neoapo cell for ID: ${animeId} when trying to insert title`);
             }
         }

         // Find the unregister button within this container
         const unregisterButton = targetContainer.querySelector(`.unregister-button[data-anime-id="${animeId}"]`);
         if (unregisterButton) {
             unregisterButton.textContent = '登録済み';
             unregisterButton.classList.add('registered'); // Add class for styling
             unregisterButton.disabled = true; // Disable the button
             // Remove the click listener to prevent re-opening dialog
             unregisterButton.removeEventListener('click', showRegistrationDialog);
             console.log(`Marked anime ID ${animeId} as registered.`);
         } else {
             console.warn(`Could not find unregister button for ID: ${animeId} in markAsRegistered`);
         }
     }


    // --- API Fetching ---
     async function fetchAniListData(query, variables = {}) {
       try {
         const response = await fetch(ANILIST_API_URL, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'Accept': 'application/json',
           },
           body: JSON.stringify({ query, variables })
         });

         if (!response.ok) {
             throw new Error(`HTTP error! status: ${response.status}`);
         }

         const data = await response.json();

         if (data.errors) {
           console.error('GraphQL エラー:', data.errors);
           const errorMessage = data.errors[0]?.message || '不明なAPIエラーが発生しました。';
           throw new Error(`API エラー: ${errorMessage}`);
         }
         if (!data.data) {
           throw new Error("APIから有効なデータが返却されませんでした。");
         }
         return data.data;
       } catch (error) {
         console.error('データ取得エラー:', error);
         throw error;
       }
     }

     async function fetchLatestAnime() {
       const query = `
         query ($page: Int, $perPage: Int) {
           Page(page: $page, perPage: $perPage) {
             media(type: ANIME, sort: ID_DESC) {
               id
               title { romaji english native }
               updatedAt
               startDate { year month day }
               format
               coverImage { medium }
             }
           }
         }
       `;
       const variables = { page: 1, perPage: ITEMS_PER_PAGE };
       const data = await fetchAniListData(query, variables);
       // Cache basic info (optional, might not be needed if details are always fetched)
       data.Page.media.forEach(anime => {
           if (!animeDataCache[anime.id]) {
              // animeDataCache[anime.id] = { ...anime }; // Example
           }
       });
       return data.Page.media;
     }

     async function fetchAnimeDetails(id) {
         if (animeDataCache[id] && animeDataCache[id].description) { // Check if full details are cached
             return animeDataCache[id];
         }

         const query = `
         query ($id: Int) {
           Media(id: $id, type: ANIME) {
             id
             title { romaji english native }
             description(asHtml: false)
             startDate { year month day }
             endDate { year month day }
             episodes
             duration
             status
             season
             seasonYear
             format
             genres
             tags { id name rank isMediaSpoiler isGeneralSpoiler description category }
             averageScore
             meanScore
             popularity
             favourites
             source
             hashtag
             synonyms
             countryOfOrigin
             studios(isMain: true) { nodes { id name isAnimationStudio } }
             externalLinks { id url site siteId type language color icon notes isDisabled }
             coverImage { large medium color }
             bannerImage
             trailer { id site thumbnail }
             updatedAt
           }
         }
       `;
       const variables = { id: parseInt(id, 10) };
       const data = await fetchAniListData(query, variables);
       animeDataCache[id] = data.Media; // Cache the full details
       return data.Media;
     }


    // --- UI Rendering ---

    /**
     * Displays the list of anime using the new card layout and vertical info table.
     * @param {Array<object>} animeList - Array of anime objects from the API.
     */
    function displayAnimeList(animeList) {
      if (!animeList || animeList.length === 0) {
        animeListContainer.innerHTML = '<p class="error">アニメデータが見つかりませんでした。</p>';
        return;
      }

      animeListContainer.innerHTML = ''; // Clear loading message or previous list

      animeList.forEach(anime => {
        const container = document.createElement('div');
        container.className = 'container';
        container.dataset.animeId = anime.id;

        const img = document.createElement('img');
        img.className = 'list-thumbnail';
        img.src = anime.coverImage?.medium || 'https://placehold.co/100x140/eee/ccc?text=N/A';
        img.alt = anime.title.native || anime.title.romaji || 'サムネイル';
        img.loading = 'lazy';
        img.onerror = function() { this.onerror=null; this.src='https://placehold.co/100x140/eee/ccc?text=N/A'; };
        container.appendChild(img);

        const detailsDiv = document.createElement('div');
        detailsDiv.className = 'details';
        container.appendChild(detailsDiv);

        const titleH2 = document.createElement('h2');
        titleH2.className = 'anime-title';
        titleH2.textContent = anime.title.native || anime.title.romaji || 'タイトルなし';
        titleH2.dataset.id = anime.id;
        titleH2.addEventListener('click', () => showAnimeDetails(anime.id));
        detailsDiv.appendChild(titleH2);

        const infoTable = document.createElement('table');
        infoTable.className = 'info-table';
        const tbody = document.createElement('tbody');

        const addVerticalInfoRow = (label, value, valueClass = '') => {
            const row = document.createElement('tr');
            const th = document.createElement('th');
            th.textContent = label;
            const td = document.createElement('td');
            if (valueClass) td.className = valueClass;
            if (label === 'neoapo' && value === '-') {
                const span = document.createElement('span');
                span.className = 'placeholder';
                span.textContent = value;
                td.appendChild(span);
            } else {
                td.textContent = value;
            }
            row.appendChild(th);
            row.appendChild(td);
            tbody.appendChild(row);
        };

        addVerticalInfoRow('形式', mapFormat(anime.format));
        addVerticalInfoRow('更新日', formatDate(anime.updatedAt));
        addVerticalInfoRow('放送日', formatDate(anime.startDate));
        addVerticalInfoRow('neoapo', '-', 'neoapo-value-cell');

        infoTable.appendChild(tbody);
        detailsDiv.appendChild(infoTable);

        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        detailsDiv.appendChild(buttonContainer);

        const searchButton = document.createElement('button');
        searchButton.textContent = '検索';
        searchButton.className = 'search-button';
        searchButton.dataset.id = anime.id;
        searchButton.dataset.titleNative = anime.title.native || anime.title.romaji || '';
        searchButton.addEventListener('click', handleSearchClickRevised);
        buttonContainer.appendChild(searchButton);

        const unregisterButton = document.createElement('button');
        unregisterButton.textContent = '新規登録';
        unregisterButton.className = 'unregister-button';
        unregisterButton.dataset.animeId = anime.id;
        unregisterButton.dataset.animeTitle = anime.title.native || anime.title.romaji || 'このアニメ';
        unregisterButton.addEventListener('click', showRegistrationDialog);
        buttonContainer.appendChild(unregisterButton);

        // Add placeholder for search result title below the button container
        const searchResultPlaceholder = document.createElement('div');
        searchResultPlaceholder.className = 'search-result-title';
        searchResultPlaceholder.style.display = 'none';
        detailsDiv.appendChild(searchResultPlaceholder); // Append below buttons

        animeListContainer.appendChild(container);
      });
    }

    /**
     * Displays the detailed information (this function remains largely unchanged).
     * @param {object} animeDetails - The detailed anime object from the API.
     */
    function displayAnimeDetails(animeDetails) {
        detailTitleElement.textContent = animeDetails.title.native || animeDetails.title.romaji || '詳細情報';
        detailContentElement.innerHTML = ''; // Clear previous content

        const animeInfoContainer = document.createElement('div');
        animeInfoContainer.className = 'anime-info-container';

        const animeInfoLeft = document.createElement('div');
        animeInfoLeft.className = 'anime-info-left';

        const animeInfoRight = document.createElement('div');
        animeInfoRight.className = 'anime-info-right';

        // Banner Image (Optional)
        if (animeDetails.bannerImage) {
            const bannerContainer = document.createElement('div');
            bannerContainer.style.marginBottom = '20px';
            const bannerImage = document.createElement('img');
            bannerImage.src = animeDetails.bannerImage;
            bannerImage.alt = `${animeDetails.title.native || animeDetails.title.romaji} バナー`;
            bannerImage.style.width = '100%';
            bannerImage.style.maxHeight = '250px';
            bannerImage.style.objectFit = 'cover';
            bannerImage.style.borderRadius = '8px';
            bannerImage.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
            bannerImage.onerror = function() { this.style.display='none'; };
            bannerContainer.appendChild(bannerImage);
            detailContentElement.appendChild(bannerContainer); // Add banner at the top
        }

        // Left Column: Cover Image
        if (animeDetails.coverImage && animeDetails.coverImage.large) {
            const coverContainer = document.createElement('div');
            coverContainer.className = 'cover-container';
            const coverImage = document.createElement('img');
            coverImage.className = 'cover-image';
            coverImage.src = animeDetails.coverImage.large;
            coverImage.alt = `${animeDetails.title.native || animeDetails.title.romaji} カバー`;
            coverImage.onerror = function() { this.onerror=null; this.src='https://placehold.co/250x350/eee/ccc?text=No+Image'; };
            coverContainer.appendChild(coverImage);
            animeInfoLeft.appendChild(coverContainer);
        } else {
             const placeholder = document.createElement('img');
             placeholder.className = 'cover-image';
             placeholder.src = 'https://placehold.co/250x350/eee/ccc?text=No+Image';
             placeholder.alt = 'カバー画像なし';
             animeInfoLeft.appendChild(placeholder);
        }
        animeInfoContainer.appendChild(animeInfoLeft);

        // Right Column: Details Table
        const detailTable = document.createElement('table');
        detailTable.className = 'detail-table';

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        ['APIパス', '項目', '値'].forEach(text => {
            const th = document.createElement('th');
            if (text === 'APIパス') th.className = 'api-path-column';
            th.textContent = text;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        detailTable.appendChild(thead);

        const tbody = document.createElement('tbody');

        const addRow = (label, value, apiPath = '-', renderAsHTML = false) => {
            const row = document.createElement('tr');
            const apiPathCell = document.createElement('td');
            apiPathCell.className = 'api-path-column';
            apiPathCell.textContent = apiPath;
            row.appendChild(apiPathCell);
            const labelCell = document.createElement('th');
            labelCell.textContent = label;
            row.appendChild(labelCell);
            const valueCell = document.createElement('td');
             if (renderAsHTML && typeof value === 'string' && (value.includes('<') || value.includes('&'))) { // Check for HTML entities too
                 try {
                    // Basic sanitization - remove script tags
                    const sanitizedValue = value.replace(/<script.*?>.*?<\/script>/gi, '');
                    // Use DOMParser for safer HTML rendering if needed, but textContent is safer
                     // For simple links etc., this might be enough
                     const tempDiv = document.createElement('div');
                     tempDiv.innerHTML = sanitizedValue; // Let browser parse HTML
                     // Append parsed nodes safely if needed, or just display as text if complex HTML isn't required
                      valueCell.innerHTML = sanitizedValue || '-'; // Be careful with innerHTML
                 } catch (e) {
                     console.error("Error rendering HTML:", e);
                     valueCell.textContent = (value !== null && value !== undefined && value !== '') ? String(value) : '-'; // Fallback
                 }
             } else {
                valueCell.textContent = (value !== null && value !== undefined && value !== '') ? String(value) : '-';
             }
            row.appendChild(valueCell);
            tbody.appendChild(row);
        };

        // Add details rows
        addRow('ID', animeDetails.id, 'Media.id');
        addRow('タイトル（日本語）', animeDetails.title.native, 'Media.title.native');
        addRow('タイトル（英語）', animeDetails.title.english, 'Media.title.english');
        addRow('タイトル（ローマ字）', animeDetails.title.romaji, 'Media.title.romaji');
        addRow('別名', animeDetails.synonyms?.join(', ') || '-', 'Media.synonyms');
        addRow('説明', animeDetails.description, 'Media.description');
        addRow('形式', mapFormat(animeDetails.format), 'Media.format');
        addRow('ステータス', mapStatus(animeDetails.status), 'Media.status');
        addRow('放送開始日', formatDate(animeDetails.startDate), 'Media.startDate');
        addRow('放送終了日', formatDate(animeDetails.endDate), 'Media.endDate');
        addRow('シーズン', `${mapSeason(animeDetails.season) || ''} ${animeDetails.seasonYear || ''}`.trim() || '-', 'Media.season / Media.seasonYear');
        addRow('エピソード数', animeDetails.episodes, 'Media.episodes');
        addRow('時間（分/話）', animeDetails.duration, 'Media.duration');
        addRow('平均スコア', animeDetails.averageScore ? `${animeDetails.averageScore}/100` : '-', 'Media.averageScore');
        addRow('人気度', animeDetails.popularity, 'Media.popularity');
        addRow('お気に入り数', animeDetails.favourites, 'Media.favourites');
        addRow('ジャンル', animeDetails.genres?.join(', ') || '-', 'Media.genres');
        const tagNames = animeDetails.tags?.map(t => t.name).slice(0, 15).join(', ') || '-';
        addRow('タグ', tagNames + (animeDetails.tags?.length > 15 ? '...' : ''), 'Media.tags.name');
        addRow('原作', mapSource(animeDetails.source), 'Media.source');
        addRow('制作会社', animeDetails.studios?.nodes?.map(s => s.name).join(', ') || '-', 'Media.studios.nodes.name');
        addRow('国', animeDetails.countryOfOrigin, 'Media.countryOfOrigin');
        addRow('ハッシュタグ', animeDetails.hashtag, 'Media.hashtag');
        addRow('更新日時', formatDateTime(animeDetails.updatedAt), 'Media.updatedAt');

        // External Links
        if (animeDetails.externalLinks && animeDetails.externalLinks.length > 0) {
            const linksHTML = animeDetails.externalLinks
                .map(link => `<a href="${link.url}" target="_blank" rel="noopener noreferrer" class="title-link">${link.site}</a>`)
                .join(' | ');
            addRow('外部リンク', linksHTML, 'Media.externalLinks', true); // Render as HTML
        } else {
            addRow('外部リンク', '-', 'Media.externalLinks');
        }

        // Trailer
        if (animeDetails.trailer?.id && animeDetails.trailer.site === 'youtube') {
            const trailerHTML = `<iframe width="100%" height="315" src="https://www.youtube-nocookie.com/embed/${animeDetails.trailer.id}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="max-width: 560px; border-radius: 8px; display: block; margin-top: 10px;"></iframe>`;
            addRow('予告編 (YouTube)', trailerHTML, 'Media.trailer', true); // Render as HTML
        } else if (animeDetails.trailer?.site) {
             addRow('予告編', `${animeDetails.trailer.site} (${animeDetails.trailer.id || 'N/A'})`, 'Media.trailer');
        } else {
            addRow('予告編', '-', 'Media.trailer');
        }

        detailTable.appendChild(tbody);
        animeInfoRight.appendChild(detailTable); // Add table to right column
        animeInfoContainer.appendChild(animeInfoRight); // Add right column to container

        detailContentElement.appendChild(animeInfoContainer); // Add main info container

        animeListContainer.style.display = 'none';
        animeDetailsContainer.style.display = 'block';
        window.scrollTo(0, 0); // Scroll to top
    }

    // --- Event Handlers ---

    /**
     * Handles clicking the 'Search' button.
     * Displays the anime title below the button as a clickable element.
     * Calls markAsRegistered when title is clicked.
     */
    function handleSearchClickRevised(event) {
        const button = event.target;
        const animeId = button.dataset.id; // Keep animeId accessible for the handler
        const nativeTitle = button.dataset.titleNative;

        const container = button.closest('.container');
        if (!container) return;
        const detailsDiv = container.querySelector('.details');
        if (!detailsDiv) return;
        const searchResultPlaceholder = detailsDiv.querySelector('.search-result-title');
        if (!searchResultPlaceholder) return;
        const neoapoValueCell = container.querySelector('.neoapo-value-cell');
        if (!neoapoValueCell) return;

        searchResultPlaceholder.textContent = nativeTitle || 'タイトル取得不可';
        searchResultPlaceholder.style.display = 'inline-block';

        // Clone and replace to ensure only one listener is attached
        searchResultPlaceholder.replaceWith(searchResultPlaceholder.cloneNode(true));
        const newSearchResultPlaceholder = detailsDiv.querySelector('.search-result-title');

        newSearchResultPlaceholder.addEventListener('click', function titleClickHandler() {
            // 1. Update the neoapo cell
            neoapoValueCell.innerHTML = '';
            neoapoValueCell.textContent = nativeTitle || '-';

            // 2. Hide the title placeholder
            newSearchResultPlaceholder.style.display = 'none';
            newSearchResultPlaceholder.textContent = '';

            // 3. Mark the corresponding button as registered
            markAsRegistered(animeId); // Pass the correct animeId

        }, { once: true }); // Automatically remove listener after first click

        button.disabled = true; // Disable search button itself
    }

    /** Shows the anime details view. */
    async function showAnimeDetails(animeId) {
      animeListContainer.style.display = 'none';
      animeDetailsContainer.style.display = 'block';
      detailTitleElement.textContent = '読み込み中...';
      detailContentElement.innerHTML = '<p class="loading">詳細データを読み込み中...</p>';
      window.scrollTo(0, 0);

      try {
        const animeDetails = await fetchAnimeDetails(animeId);
        if (animeDetails) {
            displayAnimeDetails(animeDetails);
        } else {
             throw new Error(`ID ${animeId} のアニメが見つかりませんでした。`);
        }
      } catch (error) {
        console.error(`詳細表示エラー (ID: ${animeId}):`, error);
        detailTitleElement.textContent = 'エラー';
        detailContentElement.innerHTML = `<p class="error">詳細データの取得中にエラーが発生しました: ${error.message}</p>`;
      }
    }

    /** Shows the registration confirmation dialog. */
    function showRegistrationDialog(event) {
        const button = event.target;
        if (button.disabled || button.classList.contains('registered')) {
            return; // Don't show if already registered
        }
        const animeId = button.dataset.animeId;
        const animeTitle = button.dataset.animeTitle || 'このアニメ';

        // Store data for the dialog confirmation handler
        currentAnimeIdForDialog = animeId;
        currentAnimeTitleForDialog = animeTitle;
        dialogAnimeTitle.textContent = currentAnimeTitleForDialog; // Set dialog text

        registrationDialog.style.display = 'flex'; // Show the dialog
    }

    /** Hides the registration confirmation dialog. */
    function hideRegistrationDialog() {
        registrationDialog.style.display = 'none';
        // Clear dialog state
        currentAnimeIdForDialog = null;
        currentAnimeTitleForDialog = null;
    }

    /**
     * Handles confirming the registration.
     * Calls markAsRegistered to handle title insertion and button update.
     */
    function handleRegistrationConfirm() {
        if (currentAnimeIdForDialog && currentAnimeTitleForDialog) {
            // Use the common function to update UI
            // Pass the title so it gets inserted into the neoapo cell by the function
            markAsRegistered(currentAnimeIdForDialog, currentAnimeTitleForDialog);

            // Placeholder for actual registration API call
             console.log(`Simulating registration for anime ID: ${currentAnimeIdForDialog} with title: ${currentAnimeTitleForDialog}`);
             // Example: saveRegistrationState(currentAnimeIdForDialog, true);
        } else {
            console.warn("Cannot confirm registration: Missing anime ID or title.");
        }

        hideRegistrationDialog(); // Hide dialog after processing
    }

    /** Handles navigating back from details view to list view. */
    function goBackToList() {
        animeDetailsContainer.style.display = 'none';
        animeListContainer.style.display = 'flex'; // Ensure list is displayed correctly
        detailTitleElement.textContent = '';
        detailContentElement.innerHTML = '';
    }

    // --- Initialization ---
    function initializeEventListeners() {
        backButton.addEventListener('click', goBackToList);
        dialogConfirmButton.addEventListener('click', handleRegistrationConfirm);
        dialogCancelButton.addEventListener('click', hideRegistrationDialog);
        // Close dialog if clicking outside the content
        registrationDialog.addEventListener('click', (event) => {
            if (event.target === registrationDialog) {
                hideRegistrationDialog();
            }
        });
    }

    async function loadInitialData() {
      animeListContainer.innerHTML = '<p class="loading">データを読み込み中...</p>';
      try {
        const animeList = await fetchLatestAnime();
        displayAnimeList(animeList);
      } catch (error) {
        animeListContainer.innerHTML = `<p class="error">データの初期読み込みに失敗しました: ${error.message}</p>`;
      }
    }

    // --- Run Application ---
    initializeEventListeners();
    loadInitialData();

  </script>
</body>
</html>