<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹è½ä¸‹ã‚²ãƒ¼ãƒ ï¼ˆæ”¹è‰¯ç‰ˆï¼‰</title>
  <style>
    body {
      background-color: #eee;
      margin: 0;
      padding: 0;
      text-align: center;
      font-family: sans-serif;
      /* ãƒ†ã‚­ã‚¹ãƒˆé¸æŠã‚’é˜²æ­¢ */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    canvas {
      background-color: #87CEEB; /* ç©ºè‰² */
      display: block;
      margin: 20px auto;
      border: 2px solid #333;
      touch-action: none; /* ã‚¿ãƒƒãƒæ“ä½œæ™‚ã®ãƒ–ãƒ©ã‚¦ã‚¶æ¨™æº–å‹•ä½œç„¡åŠ¹ */
    }
    #resetBtn {
      font-size: 16px;
      padding: 10px 20px;
      margin: 10px;
      display: none;
    }
  </style>
</head>
<body>
  <h1>ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹è½ä¸‹ã‚²ãƒ¼ãƒ ï¼ˆæ”¹è‰¯ç‰ˆï¼‰</h1>
  <p>ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ï¼ã‚¿ãƒƒãƒ—ã§ã‚¸ãƒ£ãƒ³ãƒ—ã€å·¦å³ã‚­ãƒ¼ã¾ãŸã¯ç”»é¢ã‚¿ãƒƒãƒ—ã§æ¨ªç§»å‹•</p>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <br>
  <button id="resetBtn">Reset</button>
  
  <script>
    // â–¼ ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šminï½maxã®æ•´æ•°ã‚’è¿”ã™
    function random(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    // â–¼ æ•µã‚’ã‚¹ãƒ‘ã‚¤ã‚­ãƒ¼ï¼ˆæ˜Ÿå½¢ï¼‰ã«æããŸã‚ã®é–¢æ•°
    function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
      let rot = Math.PI / 2 * 3;
      let x = cx;
      let y = cy;
      let step = Math.PI / spikes;
      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;
        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fill();
    }
    
    // æ•µã‚’ã‚¹ãƒ‘ã‚¤ã‚­ãƒ¼ã«æããƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°
	function drawSpikyEnemy(x, y, size) {
	  // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’ size ã«åˆã‚ã›ã¦è¨­å®š
	  ctx.font = size + "px serif";
	  ctx.textAlign = "center";
	  ctx.textBaseline = "middle";
	  // çµµæ–‡å­—ã€ŒğŸ‘¾ã€ã‚’æç”»ã™ã‚‹
	  ctx.fillText("ğŸ‘¾", x + size / 2, y + size / 2);
	}
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    
    // â–¼ ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let gameOver = false;
    let startTime, score = 0;
    // ã‚«ãƒ¡ãƒ©ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆä¸–ç•Œåº§æ¨™ã‹ã‚‰å¼•ãå€¤ï¼‰
    let cameraOffset = 0;
    const baseScrollSpeed = 1; // åˆæœŸã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦
    
    // â–¼ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šï¼ˆä¸–ç•Œåº§æ¨™ã§ç®¡ç†ï¼‰
    const player = {
      x: canvasWidth / 2 - 15,
      y: 100,
      width: 30,
      height: 30,
      vx: 0,
      vy: 0,
      speed: 3,
      jumpStrength: -10,
      onBar: false,
      lives: 3,      // ç¾åœ¨ã®ãƒ©ã‚¤ãƒ•
      maxLives: 3,   // æœ€å¤§ãƒ©ã‚¤ãƒ•
      invincible: false,
      invincibleTimer: 0
    };
    
    const baseGravity = 0.3; // åˆæœŸé‡åŠ›
    
    // â–¼ ãƒãƒ¼ï¼ˆè¶³å ´ï¼‰ã®é…åˆ—ã¨ç”Ÿæˆæ¡ä»¶
    let bars = [];
    const barMinWidth = 50, barMaxWidth = 150;
    const barHeight = 10;
    let nextBarY = 150;
    
    // â–¼ æ–°ä»•æ§˜ï¼šãƒãƒ¼ã®ç¨®é¡
    // å„ãƒãƒ¼ã« type ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒãŸã›ã‚‹
    // type: "normal"ï¼ˆé€šå¸¸ï¼‰ã€"green"ï¼ˆè‡ªå‹•ã‚¸ãƒ£ãƒ³ãƒ—ï¼‰ã€"blue"ï¼ˆå·¦å³ã‚¨ãƒ¬ãƒ™ãƒ¼ã‚¿ãƒ¼ï¼‰
    
    // â–¼ æ•µè¨­å®šï¼šãƒãƒ¼ã”ã¨ã«30%ã®ç¢ºç‡ã§é…ç½®ã€ã‚µã‚¤ã‚º15px
    const enemyProbability = 0.3;
    const enemySize = 15;
    
    // â–¼ è¿½åŠ ä»•æ§˜ï¼šå¤©äº•è¡çªæ™‚ã«ãƒãƒ¼ã‚’é€éçŠ¶æ…‹ã«ã™ã‚‹ãŸã‚ã®ã‚¿ã‚¤ãƒãƒ¼ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
    let barTransparentTimer = 0;
    
    // â–¼ çµµæ–‡å­—ã‚¢ã‚¤ãƒ†ãƒ ç”¨ã®å¤‰æ•°
    let items = [];
    let nextItemY = 200;  // ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆã®åŸºæº–ã¨ãªã‚‹Yåº§æ¨™
    const itemSize = 20;  // ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚µã‚¤ã‚ºï¼ˆåˆ¤å®šç”¨ï¼‰
    
    // â–¼ ãƒã‚¤ã‚¹ã‚³ã‚¢ç”¨ã®å¤‰æ•°ï¼ˆlocalStorageã‹ã‚‰å–å¾—ï¼‰
    let highScore = parseInt(localStorage.getItem("highScore")) || 0;
    let hasUpdatedHighScore = false;
    
    // â–¼ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ç®¡ç†
    const keys = {};
    document.addEventListener("keydown", function(e) {
      // çŸ¢å°ã‚­ãƒ¼ãƒ»ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’é˜²æ­¢
      if (["ArrowLeft", "ArrowRight", "Space"].includes(e.code)) {
        e.preventDefault();
      }
      keys[e.code] = true;
    });
    document.addEventListener("keyup", function(e) {
      keys[e.code] = false;
    });
    
    // â–¼ ã‚¹ãƒãƒ›ï¼ãƒã‚¦ã‚¹ç”¨å…¥åŠ›å‡¦ç†
    function handleInputStart(e) {
      e.preventDefault();
      let x;
      if (e.touches && e.touches.length > 0) {
        x = e.touches[0].clientX - canvas.getBoundingClientRect().left;
      } else {
        x = e.clientX - canvas.getBoundingClientRect().left;
      }
      // ç”»é¢å·¦åŠåˆ†ãªã‚‰å·¦ç§»å‹•ã€å³åŠåˆ†ãªã‚‰å³ç§»å‹•
      if (x < canvasWidth / 2) {
        keys["ArrowLeft"] = true;
        keys["ArrowRight"] = false;
      } else {
        keys["ArrowRight"] = true;
        keys["ArrowLeft"] = false;
      }
      // ã‚¿ãƒƒãƒ—ï¼ã‚¯ãƒªãƒƒã‚¯æ™‚ã¯ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆè¶³å ´ã«ä¹—ã£ã¦ã„ã‚‹ãªã‚‰ï¼‰
      if (player.onBar) {
        player.vy = player.jumpStrength;
        player.onBar = false;
      }
    }
    function handleInputEnd(e) {
      e.preventDefault();
      keys["ArrowLeft"] = false;
      keys["ArrowRight"] = false;
    }
    canvas.addEventListener("touchstart", handleInputStart, false);
    canvas.addEventListener("touchend", handleInputEnd, false);
    canvas.addEventListener("mousedown", handleInputStart, false);
    canvas.addEventListener("mouseup", handleInputEnd, false);
    
    // â–¼ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã€ç”»é¢ã‚¿ãƒƒãƒ—ï¼ã‚¯ãƒªãƒƒã‚¯ã§å†ã‚¹ã‚¿ãƒ¼ãƒˆ
    canvas.addEventListener("click", function() {
      if (gameOver) {
        resetGame();
      }
    });
    
    // â–¼ ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³è¨­å®š
    const resetBtn = document.getElementById("resetBtn");
    resetBtn.addEventListener("click", resetGame);
    
    // â–¼ ãƒãƒ¼ç”Ÿæˆé–¢æ•°
    function spawnBars() {
      while (nextBarY < cameraOffset + canvasHeight + 200) {
        let barWidth = random(barMinWidth, barMaxWidth);
        let barX = random(0, canvasWidth - barWidth);
        // ãƒãƒ¼ã®ç¨®é¡ã‚’æ±ºå®šï¼ˆ70%:normal, 15%:green, 15%:blueï¼‰
        let r = Math.random();
        let type = "normal";
        if (r < 0.7) {
          type = "normal";
        } else if (r < 0.85) {
          type = "green";
        } else {
          type = "blue";
        }
        let bar = {
          x: barX,
          y: nextBarY,
          width: barWidth,
          height: barHeight,
          type: type,
          enemy: null
        };
        // é’ã®ãƒãƒ¼ã¯å·¦å³ã«å‹•ãï¼ˆã‚¨ãƒ¬ãƒ™ãƒ¼ã‚¿ãƒ¼ï¼‰
        if (type === "blue") {
          bar.vx = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 1 + 0.5);
        }
        // æ•µé…ç½®ï¼ˆ30%ã®ç¢ºç‡ã€é€šå¸¸ã©ãŠã‚Šï¼‰
        if (Math.random() < enemyProbability) {
          let enemyX = random(barX, barX + barWidth - enemySize);
          let enemy = {
            x: enemyX,
            y: nextBarY - enemySize,
            size: enemySize,
            vx: (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.5 + 0.5)
          };
          bar.enemy = enemy;
        }
        bars.push(bar);
        nextBarY += random(80, 150);
      }
    }
    
    // â–¼ çµµæ–‡å­—ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆé–¢æ•°
    function spawnItems() {
      while (nextItemY < cameraOffset + canvasHeight + 200) {
        let itemX = random(0, canvasWidth - itemSize);
        let item = {
          x: itemX,
          y: nextItemY,
          size: itemSize
        };
        items.push(item);
        nextItemY += random(200, 300);
      }
    }
    
    // åˆæœŸãƒãƒ¼ç”Ÿæˆ
    spawnBars();
    
    // â–¼ ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
    function initGame() {
      gameOver = false;
      cameraOffset = 0;
      startTime = Date.now();
      score = 0;
      barTransparentTimer = 0;
      hasUpdatedHighScore = false;
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆæœŸåŒ–ï¼ˆæœ€å¤§ãƒ©ã‚¤ãƒ•ã«åˆã‚ã›ã‚‹ï¼‰
      player.x = canvasWidth / 2 - player.width / 2;
      player.y = 100;
      player.vx = 0;
      player.vy = 0;
      player.onBar = false;
      player.lives = player.maxLives;
      player.invincible = false;
      player.invincibleTimer = 0;
      // ãƒãƒ¼åˆæœŸåŒ–
      bars = [];
      nextBarY = 150;
      spawnBars();
      // ã‚¢ã‚¤ãƒ†ãƒ åˆæœŸåŒ–
      items = [];
      nextItemY = 200;
      spawnItems();
      resetBtn.style.display = "none";
      gameLoop();
    }
    function resetGame() {
      initGame();
    }
    
    // â–¼ çŸ©å½¢åŒå£«ã®è¡çªåˆ¤å®š
    function rectsIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }
    
    // â–¼ ãƒ¡ã‚¤ãƒ³ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆå‡¦ç†
    function update() {
      if (gameOver) return;
      
      let elapsed = (Date.now() - startTime) / 1000;
      score = Math.floor(elapsed * 10);
      
      // è½ä¸‹é€Ÿåº¦ãƒ»é‡åŠ›ã¯æ™‚é–“çµŒéã§æ¼¸å¢—
      let currentScrollSpeed = baseScrollSpeed + elapsed * 0.05;
      let currentGravity = baseGravity + elapsed * 0.02;
      cameraOffset += currentScrollSpeed;
      
      // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼ã‚¿ãƒƒãƒ—ã«ã‚ˆã‚‹å·¦å³ç§»å‹•
      if (keys["ArrowLeft"]) {
        player.x -= player.speed;
      }
      if (keys["ArrowRight"]) {
        player.x += player.speed;
      }
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvasWidth) player.x = canvasWidth - player.width;
      
      // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆè¶³å ´ã«ä¹—ã£ã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
      if (keys["Space"] && player.onBar) {
        player.vy = player.jumpStrength;
        player.onBar = false;
      }
      
      // é‡åŠ›é©ç”¨
      player.vy += currentGravity;
      player.y += player.vy;
      
      // é’ã®ãƒãƒ¼ã®å·¦å³ç§»å‹•æ›´æ–°
      for (let bar of bars) {
        if (bar.type === "blue") {
          bar.x += bar.vx;
          if (bar.x < 0) {
            bar.x = 0;
            bar.vx = -bar.vx;
          }
          if (bar.x + bar.width > canvasWidth) {
            bar.x = canvasWidth - bar.width;
            bar.vx = -bar.vx;
          }
        }
      }
      
      // æ•µã®å·¦å³ç§»å‹•æ›´æ–°ï¼ˆå„ãƒãƒ¼ã«é…ç½®ã•ã‚ŒãŸæ•µï¼‰
      for (let bar of bars) {
        if (bar.enemy) {
          bar.enemy.x += bar.enemy.vx;
          // æ•µã¯ãƒãƒ¼å†…ã‚’ç§»å‹•ï¼ˆãƒãƒ¼ã®ç¯„å›²å†…ã§è·³ã­è¿”ã‚‹ï¼‰
          if (bar.enemy.x < bar.x) {
            bar.enemy.x = bar.x;
            bar.enemy.vx = -bar.enemy.vx;
          }
          if (bar.enemy.x + bar.enemy.size > bar.x + bar.width) {
            bar.enemy.x = bar.x + bar.width - bar.enemy.size;
            bar.enemy.vx = -bar.enemy.vx;
          }
        }
      }
      
      // â–¼ å¤©äº•è¡çªå‡¦ç†ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç”»é¢ä¸Šã§ã®ä½ç½®ãŒ0æœªæº€ã®å ´åˆ
      let playerScreenY = player.y - cameraOffset;
      if (playerScreenY < 0 && barTransparentTimer <= 0) {
        player.lives--;
        // ãƒ©ã‚¤ãƒ•ãŒï¼ä»¥ä¸‹ãªã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
        if (player.lives <= 0) {
          gameOver = true;
        }
        barTransparentTimer = 10; // 10ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆç´„1ç§’ï¼‰ã®é€éçŠ¶æ…‹
        player.vy = 5; // ä¸‹å‘ãã«å¼·åˆ¶è½ä¸‹
      }
      
      // â–¼ ãƒãƒ¼é€éã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
      if (barTransparentTimer > 0) {
        barTransparentTimer--;
      }
      
      // â–¼ ãƒãƒ¼ç”Ÿæˆ
      spawnBars();
      
      // â–¼ ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆ
      spawnItems();
      
      // â–¼ ãƒãƒ¼ã¨ã®è¡çªåˆ¤å®šï¼ˆé€éçŠ¶æ…‹ä¸­ã¯åˆ¤å®šã—ãªã„ï¼‰
      if (barTransparentTimer <= 0) {
        player.onBar = false;
        for (let bar of bars) {
          if (player.x < bar.x + bar.width && player.x + player.width > bar.x) {
            if (player.vy >= 0 &&
                player.y + player.height >= bar.y &&
                player.y + player.height <= bar.y + bar.height + player.vy) {
              // ãƒãƒ¼ç¨®åˆ¥ã”ã¨ã«ã‚®ãƒŸãƒƒã‚¯å‡¦ç†
              if (bar.type === "green") {
                // ç·‘ã®ãƒãƒ¼ï¼šç€åœ°ã¨åŒæ™‚ã«è‡ªå‹•ã‚¸ãƒ£ãƒ³ãƒ—
                player.y = bar.y - player.height;
                player.vy = player.jumpStrength;
                player.onBar = true;
              } else if (bar.type === "blue") {
                // é’ã®ãƒãƒ¼ï¼šé€šå¸¸ç€åœ°ï¼‹ãƒãƒ¼ã®æ¨ªç§»å‹•åˆ†ã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«åæ˜ 
                player.y = bar.y - player.height;
                player.vy = 0;
                player.onBar = true;
                player.x += bar.vx;
              } else { // normal
                player.y = bar.y - player.height;
                player.vy = 0;
                player.onBar = true;
              }
              break;
            }
          }
        }
      }
      
      // â–¼ æ•µã¨ã®è¡çªåˆ¤å®š
      for (let bar of bars) {
        if (bar.enemy && rectsIntersect(player.x, player.y, player.width, player.height,
                                        bar.enemy.x, bar.enemy.y, bar.enemy.size, bar.enemy.size)) {
          if (!player.invincible) {
            player.lives--;
            // ãƒ©ã‚¤ãƒ•ãŒï¼ä»¥ä¸‹ãªã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
            if (player.lives <= 0) {
              gameOver = true;
            }
            player.invincible = true;
            player.invincibleTimer = 60; // ç´„1ç§’ã®ç„¡æ•µ
          }
        }
      }
      
      // â–¼ çµµæ–‡å­—ã‚¢ã‚¤ãƒ†ãƒ ã¨ã®è¡çªåˆ¤å®š
      for (let i = items.length - 1; i >= 0; i--) {
        let item = items[i];
        if (rectsIntersect(player.x, player.y, player.width, player.height,
                           item.x, item.y, item.size, item.size)) {
          score += 100;
          items.splice(i, 1);
        }
      }
      
      // â–¼ ç„¡æ•µã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
      if (player.invincible) {
        player.invincibleTimer--;
        if (player.invincibleTimer <= 0) {
          player.invincible = false;
        }
      }
      
      // â–¼ ç”»é¢ä¸‹ï¼ˆè½ä¸‹ï¼‰åˆ¤å®š
      let playerScreenBottom = player.y - cameraOffset + player.height;
      if (playerScreenBottom > canvasHeight) {
        gameOver = true;
      }
    }
    
    // â–¼ æç”»å‡¦ç†
    function draw() {
      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã€ã¾ã ãƒã‚¤ã‚¹ã‚³ã‚¢ãŒæ›´æ–°ã•ã‚Œã¦ã„ãªã‘ã‚Œã°æ›´æ–°ã™ã‚‹
      if (gameOver && !hasUpdatedHighScore) {
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("highScore", highScore);
        }
        hasUpdatedHighScore = true;
      }
      
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      // èƒŒæ™¯
      ctx.fillStyle = "#87CEEB";
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // ãƒãƒ¼æç”»ï¼šé€éã‚¿ã‚¤ãƒãƒ¼ä¸­ã¯åŠé€æ˜ã§æç”»
      if (barTransparentTimer > 0) {
        ctx.globalAlpha = 0.3;
      } else {
        ctx.globalAlpha = 1;
      }
      for (let bar of bars) {
        let barScreenY = bar.y - cameraOffset;
        if (barScreenY + bar.height >= -20 && barScreenY <= canvasHeight + 20) {
          // ãƒãƒ¼è‰²ã¯ç¨®é¡ã§å¤‰åŒ–
          if (bar.type === "green") {
            ctx.fillStyle = "green";
          } else if (bar.type === "blue") {
            ctx.fillStyle = "blue";
          } else {
            ctx.fillStyle = "#654321";
          }
          ctx.fillRect(bar.x, barScreenY, bar.width, bar.height);
          // æ•µæç”»ï¼ˆã‚ã‚‹å ´åˆï¼‰
          if (bar.enemy) {
            let enemyScreenY = bar.enemy.y - cameraOffset;
            drawSpikyEnemy(bar.enemy.x, enemyScreenY, bar.enemy.size);
          }
        }
      }
      ctx.globalAlpha = 1;
      
      // â–¼ çµµæ–‡å­—ã‚¢ã‚¤ãƒ†ãƒ æç”»
      ctx.font = "24px serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (let item of items) {
        let itemScreenY = item.y - cameraOffset;
        if (itemScreenY > -20 && itemScreenY < canvasHeight + 20) {
          ctx.fillText("ğŸ°", item.x + item.size/2, itemScreenY + item.size/2);
        }
      }
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»ï¼ˆç„¡æ•µæ™‚ã¯åŠé€æ˜ï¼‰
      let playerScreenY = player.y - cameraOffset;
      if (player.invincible) {
        ctx.globalAlpha = 0.5;
      }
      ctx.fillStyle = "#FFCCCC";
      ctx.beginPath();
      ctx.arc(player.x + player.width/2, playerScreenY + player.height/2, player.width/2, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "black";
      // ç›®
      ctx.beginPath();
      ctx.arc(player.x + player.width/2 - 5, playerScreenY + player.height/2 - 3, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(player.x + player.width/2 + 5, playerScreenY + player.height/2 - 3, 2, 0, Math.PI * 2);
      ctx.fill();
      // ã«ã£ã“ã‚Šç¬‘ã£ãŸå£
      ctx.beginPath();
      ctx.arc(player.x + player.width/2, playerScreenY + player.height/2 + 2, 6, 0, Math.PI, false);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // ã‚¹ã‚³ã‚¢è¡¨ç¤ºï¼ˆå·¦ä¸Šï¼‰
      ctx.fillStyle = "black";
      ctx.font = "20px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 10, 30);
      ctx.fillText("High Score: " + highScore, 10, 60);
      
      // ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ã‚¸æç”»ï¼ˆå³ä¸Šï¼‰
      const gaugeX = canvasWidth - 120;
      const gaugeY = 10;
      const gaugeWidth = 100;
      const gaugeHeight = 20;
      ctx.strokeStyle = "black";
      ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
      let lifeRatio = player.lives / player.maxLives;
      ctx.fillStyle = "red";
      ctx.fillRect(gaugeX, gaugeY, gaugeWidth * lifeRatio, gaugeHeight);
      
      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = "white";
        ctx.font = "40px sans-serif";
        ctx.fillText("GAME OVER", canvasWidth/2 - 120, canvasHeight/2);
      }
    }
    
    // â–¼ ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
    function gameLoop() {
      update();
      draw();
      if (!gameOver) {
        requestAnimationFrame(gameLoop);
      }
    }
    
    // â–¼ ã‚²ãƒ¼ãƒ é–‹å§‹
    initGame();
  </script>
</body>
</html>
