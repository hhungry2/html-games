<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹è½ä¸‹ã‚²ãƒ¼ãƒ ï¼ˆæœ€é©åŒ–ï¼†ä¿®æ­£ç‰ˆï¼‰</title>
  <style>
    body {
      background-color: #eee;
      margin: 0;
      padding: 0;
      text-align: center;
      font-family: sans-serif;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    canvas {
      background-color: #87CEEB;
      display: block;
      margin: 20px auto;
      border: 2px solid #333;
      touch-action: none;
    }
    #resetBtn {
      font-size: 16px;
      padding: 10px 20px;
      margin: 10px;
      display: none;
    }
  </style>
</head>
<body>
  <h1>ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹è½ä¸‹ã‚²ãƒ¼ãƒ ï¼ˆæœ€é©åŒ–ï¼†ä¿®æ­£ç‰ˆï¼‰</h1>
  <p>ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ï¼ã‚¿ãƒƒãƒ—ã§ã‚¸ãƒ£ãƒ³ãƒ—ã€å·¦å³ã‚­ãƒ¼ã¾ãŸã¯ç”»é¢ã‚¿ãƒƒãƒ—ã§æ¨ªç§»å‹•</p>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <br>
  <button id="resetBtn">Reset</button>
  
  <script>
    (function () {
      "use strict";
      // å®šæ•°ã®å®šç¾©
      const CANVAS_WIDTH = 400;
      const CANVAS_HEIGHT = 600;
      const BASE_SCROLL_SPEED = 1;
      const BASE_GRAVITY = 0.3;
      const BAR_MIN_WIDTH = 50, BAR_MAX_WIDTH = 150, BAR_HEIGHT = 10;
      const ENEMY_PROBABILITY = 0.3, ENEMY_SIZE = 15;
      const ITEM_SIZE = 20;
      const LIFE_ICON_SIZE = 24, LIFE_SPACING = 30;
      
      // Canvas é–¢é€£
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const resetBtn = document.getElementById("resetBtn");
      
      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãƒ»å¤‰æ•°
      // gameState: "start" / "playing" / "gameover"
      let gameState = "start";
      let startTime, score, bonusScore, cameraOffset, barTransparentTimer, hasUpdatedHighScore;
      let bars, items, effects, nextBarY, nextItemY;
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š
      const player = {
        x: CANVAS_WIDTH / 2 - 15,
        y: 100,
        width: 30,
        height: 30,
        vx: 0,
        vy: 0,
        speed: 3,
        jumpStrength: -10,
        onBar: false,
        lives: 3,
        maxLives: 3,
        invincible: false,
        invincibleTimer: 0
      };
      
      let highScore = parseInt(localStorage.getItem("highScore")) || 0;
      const keys = {};
      
      // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
      const random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      function rectsIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
        return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
      }
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼ã‚¿ãƒƒãƒï¼ãƒã‚¦ã‚¹ï¼‰
      document.addEventListener("keydown", (e) => {
        if (["ArrowLeft", "ArrowRight", "Space"].includes(e.code)) e.preventDefault();
        keys[e.code] = true;
        // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢çŠ¶æ…‹ã§ã‚­ãƒ¼å…¥åŠ›ãŒã‚ã‚Œã°ã‚²ãƒ¼ãƒ é–‹å§‹
        if(gameState === "start") initGame();
      });
      document.addEventListener("keyup", (e) => { keys[e.code] = false; });
      
      const handleInputStart = (e) => {
        e.preventDefault();
        const x = e.touches ? e.touches[0].clientX - canvas.getBoundingClientRect().left : e.clientX - canvas.getBoundingClientRect().left;
        if (x < CANVAS_WIDTH / 2) { keys["ArrowLeft"] = true; keys["ArrowRight"] = false; }
        else { keys["ArrowRight"] = true; keys["ArrowLeft"] = false; }
        // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ãªã‚‰ã‚²ãƒ¼ãƒ é–‹å§‹
        if(gameState === "start") {
          initGame();
          return;
        }
        if (player.onBar) {
          player.vy = player.jumpStrength;
          player.onBar = false;
        }
      };
      const handleInputEnd = (e) => {
        e.preventDefault();
        keys["ArrowLeft"] = keys["ArrowRight"] = false;
      };
      canvas.addEventListener("touchstart", handleInputStart, false);
      canvas.addEventListener("touchend", handleInputEnd, false);
      canvas.addEventListener("mousedown", handleInputStart, false);
      canvas.addEventListener("mouseup", handleInputEnd, false);
      
      // ã‚¯ãƒªãƒƒã‚¯ã§ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã‚‚ãƒªã‚»ãƒƒãƒˆï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã‚‚ï¼‰
      canvas.addEventListener("click", () => {
        if(gameState === "start" || gameState === "gameover") {
          initGame();
        }
      });
      resetBtn.addEventListener("click", resetGame);
      
      // ãƒãƒ¼ç”Ÿæˆ
      function spawnBars() {
        while (nextBarY < cameraOffset + CANVAS_HEIGHT + 200) {
          const barWidth = random(BAR_MIN_WIDTH, BAR_MAX_WIDTH);
          const barX = random(0, CANVAS_WIDTH - barWidth);
          let type = "normal";
          const r = Math.random();
          if (r >= 0.7 && r < 0.85) type = "green";
          else if (r >= 0.85) type = "blue";
          const bar = { x: barX, y: nextBarY, width: barWidth, height: BAR_HEIGHT, type, enemy: null };
          if (type === "blue") {
            bar.vx = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 1 + 0.5);
          }
          if (Math.random() < ENEMY_PROBABILITY) {
            const enemyX = random(barX, barX + barWidth - ENEMY_SIZE);
            bar.enemy = { x: enemyX, y: nextBarY - ENEMY_SIZE, size: ENEMY_SIZE, vx: (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.5 + 0.5) };
          }
          bars.push(bar);
          nextBarY += random(80, 150);
        }
      }
      
      // ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆ
      function spawnItems() {
        while (nextItemY < cameraOffset + CANVAS_HEIGHT + 200) {
          const itemX = random(0, CANVAS_WIDTH - ITEM_SIZE);
          items.push({ x: itemX, y: nextItemY, size: ITEM_SIZE });
          nextItemY += random(200, 300);
        }
      }
      
      // æ›´æ–°å‡¦ç†ï¼ˆã‚²ãƒ¼ãƒ ä¸­ã®ã¿ï¼‰
      function update() {
        if (gameState !== "playing") return;
        const elapsed = (Date.now() - startTime) / 1000;
        score = Math.floor(elapsed * 10) + bonusScore;
        const currentScrollSpeed = BASE_SCROLL_SPEED + elapsed * 0.05;
        const currentGravity = BASE_GRAVITY + elapsed * 0.02;
        cameraOffset += currentScrollSpeed;
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
        if (keys["ArrowLeft"]) player.x -= player.speed;
        if (keys["ArrowRight"]) player.x += player.speed;
        player.x = Math.max(0, Math.min(player.x, CANVAS_WIDTH - player.width));
        if (keys["Space"] && player.onBar) {
          player.vy = player.jumpStrength;
          player.onBar = false;
        }
        player.vy += currentGravity;
        player.y += player.vy;
        
        // é’ãƒãƒ¼ã®å·¦å³ç§»å‹•æ›´æ–°
        for (let bar of bars) {
          if (bar.type === "blue") {
            bar.x += bar.vx;
            if (bar.x < 0) { bar.x = 0; bar.vx = -bar.vx; }
            if (bar.x + bar.width > CANVAS_WIDTH) { bar.x = CANVAS_WIDTH - bar.width; bar.vx = -bar.vx; }
          }
        }
        // æ•µã®ç§»å‹•æ›´æ–°
        for (let bar of bars) {
          if (bar.enemy) {
            bar.enemy.x += bar.enemy.vx;
            if (bar.enemy.x < bar.x) { bar.enemy.x = bar.x; bar.enemy.vx = -bar.enemy.vx; }
            if (bar.enemy.x + bar.enemy.size > bar.x + bar.width) { bar.enemy.x = bar.x + bar.width - bar.enemy.size; bar.enemy.vx = -bar.enemy.vx; }
          }
        }
        
        // å¤©äº•è¡çªå‡¦ç†
        const playerScreenY = player.y - cameraOffset;
        if (playerScreenY < 0 && barTransparentTimer <= 0) {
          player.lives--;
          if (player.lives <= 0) gameState = "gameover";
          barTransparentTimer = 10;
          player.vy = 5;
        }
        if (barTransparentTimer > 0) barTransparentTimer--;
        
        spawnBars();
        spawnItems();
        
        // ãƒãƒ¼ã¨ã®è¡çªåˆ¤å®š
        if (barTransparentTimer <= 0) {
          player.onBar = false;
          for (let bar of bars) {
            if (player.x < bar.x + bar.width && player.x + player.width > bar.x) {
              if (player.vy >= 0 &&
                  player.y + player.height >= bar.y &&
                  player.y + player.height <= bar.y + bar.height + player.vy) {
                if (bar.type === "green") {
                  player.y = bar.y - player.height;
                  player.vy = player.jumpStrength;
                  player.onBar = true;
                } else if (bar.type === "blue") {
                  player.y = bar.y - player.height;
                  player.vy = 0;
                  player.onBar = true;
                  player.x += bar.vx;
                } else {
                  player.y = bar.y - player.height;
                  player.vy = 0;
                  player.onBar = true;
                }
                break;
              }
            }
          }
        }
        
        // æ•µã¨ã®è¡çªåˆ¤å®š
        for (let bar of bars) {
          if (bar.enemy && rectsIntersect(player.x, player.y, player.width, player.height,
                                          bar.enemy.x, bar.enemy.y, bar.enemy.size, bar.enemy.size)) {
            if (!player.invincible) {
              player.lives--;
              if (player.lives <= 0) gameState = "gameover";
              player.invincible = true;
              player.invincibleTimer = 60;
            }
          }
        }
        
        // ã‚¢ã‚¤ãƒ†ãƒ ã¨ã®è¡çªåˆ¤å®š
        for (let i = items.length - 1; i >= 0; i--) {
          const item = items[i];
          if (rectsIntersect(player.x, player.y, player.width, player.height,
                             item.x, item.y, item.size, item.size)) {
            bonusScore += 100;
            effects.push({ x: item.x + item.size / 2, y: item.y, alpha: 1, timer: 30, text: "âœ¨" });
            items.splice(i, 1);
          }
        }
        
        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
        for (let i = effects.length - 1; i >= 0; i--) {
          const eff = effects[i];
          eff.timer--;
          eff.y -= 0.5;
          eff.alpha = eff.timer / 30;
          if (eff.timer <= 0) effects.splice(i, 1);
        }
        
        if (player.invincible) {
          player.invincibleTimer--;
          if (player.invincibleTimer <= 0) player.invincible = false;
        }
        
        // ç”»é¢ä¸‹éƒ¨è¡çªåˆ¤å®š
        if (player.y - cameraOffset + player.height > CANVAS_HEIGHT) gameState = "gameover";
      }
      
      // æç”»å‡¦ç†
      function draw() {
        // ãƒã‚¤ã‚¹ã‚³ã‚¢æ›´æ–°ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®ã¿ï¼‰
        if (gameState === "gameover" && !hasUpdatedHighScore) {
          if (score > highScore) {
            highScore = score;
            localStorage.setItem("highScore", highScore);
          }
          hasUpdatedHighScore = true;
        }
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        // èƒŒæ™¯æç”»
        ctx.fillStyle = "#87CEEB";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã®æç”»
        if (gameState === "start") {
          ctx.fillStyle = "black";
          ctx.font = "30px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("Tap to Start", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
          return;  // ä»¥é™ã¯æç”»ã›ãšã«çµ‚äº†
        }
        
        // ãƒãƒ¼ãŠã‚ˆã³æ•µã®æç”»
        ctx.globalAlpha = (barTransparentTimer > 0 ? 0.3 : 1);
        for (let bar of bars) {
          const barScreenY = bar.y - cameraOffset;
          if (barScreenY + bar.height >= -20 && barScreenY <= CANVAS_HEIGHT + 20) {
            ctx.fillStyle = bar.type === "green" ? "green" : (bar.type === "blue" ? "blue" : "#654321");
            ctx.fillRect(bar.x, barScreenY, bar.width, BAR_HEIGHT);
            if (bar.enemy) {
              const enemyScreenY = bar.enemy.y - cameraOffset;
              ctx.font = bar.enemy.size + "px sans-serif";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("ğŸ‘¾", bar.enemy.x + bar.enemy.size / 2, enemyScreenY + bar.enemy.size / 2);
            }
          }
        }
        ctx.globalAlpha = 1;
        
        // ã‚¢ã‚¤ãƒ†ãƒ æç”»
        ctx.font = "24px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let item of items) {
          const itemScreenY = item.y - cameraOffset;
          if (itemScreenY > -20 && itemScreenY < CANVAS_HEIGHT + 20) {
            ctx.fillText("ğŸ°", item.x + item.size / 2, itemScreenY + item.size / 2);
          }
        }
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»ï¼ˆãƒšãƒ³ã‚®ãƒ³ğŸ§ï¼‰
        const playerScreenY = player.y - cameraOffset;
        if (player.invincible) ctx.globalAlpha = 0.5;
        ctx.font = "30px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ğŸ§", player.x + player.width / 2, playerScreenY + player.height / 2);
        ctx.globalAlpha = 1;
        
        // ã‚¹ã‚³ã‚¢ãƒ»ãƒã‚¤ã‚¹ã‚³ã‚¢è¡¨ç¤º
        ctx.fillStyle = "black";
        ctx.font = "20px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("High Score: " + highScore, CANVAS_WIDTH / 2, 20);
        ctx.textAlign = "left";
        ctx.fillText("Score: " + score, 10, 50);
        
        // ãƒªãƒƒãƒãªãƒ©ã‚¤ãƒ•è¡¨ç¤ºï¼ˆãƒšãƒ³ã‚®ãƒ³ã‚¢ã‚¤ã‚³ãƒ³ï¼‰
        const startX = CANVAS_WIDTH - (player.maxLives * LIFE_SPACING) - 10;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowBlur = 4;
        for (let i = 0; i < player.maxLives; i++) {
          ctx.globalAlpha = i < player.lives ? 1 : 0.3;
          ctx.font = LIFE_ICON_SIZE + "px sans-serif";
          ctx.fillText("ğŸ§", startX + i * LIFE_SPACING + LIFE_SPACING / 2, 50);
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        
        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»
        ctx.save();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let eff of effects) {
          ctx.globalAlpha = eff.alpha;
          ctx.font = "30px sans-serif";
          ctx.fillText(eff.text, eff.x, eff.y - cameraOffset);
        }
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çŠ¶æ…‹ãªã‚‰è¡¨ç¤ºï¼‰
        if (gameState === "gameover") {
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          ctx.fillStyle = "white";
          ctx.font = "40px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
        }
      }
      
      // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ï¼ˆã‚²ãƒ¼ãƒ çŠ¶æ…‹ã«é–¢ã‚ã‚‰ãšæç”»ã¯ç¶™ç¶šï¼‰
      function gameLoop() {
        if (gameState === "playing") update();
        draw();
        requestAnimationFrame(gameLoop);
      }
      
      // resetGame é–¢æ•°ï¼ˆã‚²ãƒ¼ãƒ å†é–‹ç”¨ï¼‰
      function resetGame() {
        initGame();
      }
      
      // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
      function initGame() {
        gameState = "playing";
        cameraOffset = 0;
        startTime = Date.now();
        score = bonusScore = 0;
        barTransparentTimer = 0;
        hasUpdatedHighScore = false;
        effects = [];
        nextBarY = 150;
        nextItemY = 200;
        player.x = CANVAS_WIDTH / 2 - player.width / 2;
        player.y = 100;
        player.vx = player.vy = 0;
        player.onBar = false;
        player.lives = player.maxLives;
        player.invincible = false;
        player.invincibleTimer = 0;
        bars = [];
        items = [];
        spawnBars();
        spawnItems();
        resetBtn.style.display = "none";
      }
      
      // åˆå›ã¯ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã‚’è¡¨ç¤º
      gameLoop();
    })();
  </script>
</body>
</html>
