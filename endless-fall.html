<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- ã‚¹ãƒãƒ›ã§ç”»é¢å…¨ä½“ã«è¡¨ç¤ºã•ã›ã‚‹ãŸã‚ã®viewportè¨­å®š -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=0.7, user-scalable=no">
  <title>ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹è½ä¸‹ã‚²ãƒ¼ãƒ </title>
  <style>
    * {
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    body {
      margin: 0;
      padding: 0;
      background: #eee;
      font-family: sans-serif;
    }
    /* å¿…è¦ã«å¿œã˜ã¦canvasã®CSSã§100%è¡¨ç¤ºã‚’æŒ‡å®š */
    canvas {
      display: block;
      background-color: #87CEEB;
    }
    #controls {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 120px;
    }
    #controls button {
      width: 100%;
      height: 100%;
      font-size: 36px;
      border: none;
      background-color: #fff;
    }
    #startBtn {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 40px;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      background-color: #fff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
      z-index: 200;
      display: none;
    }
    #repoLink {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
      text-decoration: none;
      z-index: 300;
      display: none;
    }
  </style>
</head>
<body>
  <a id="repoLink" href="https://github.com/hhungry2/html-games" target="_blank">GitHub Repository</a>
  <canvas id="gameCanvas"></canvas>
  <div id="controls">
    <button id="jumpBtn">ã‚¸ãƒ£ãƒ³ãƒ—</button>
  </div>
  <button id="startBtn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  
  <script>
    (function(){
      "use strict";
      
      // iPhoneã‹ã©ã†ã‹ã®åˆ¤å®šã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨çµµæ–‡å­—
      const isIphone = /iPhone/.test(navigator.userAgent);
      const playerEmoji = isIphone ? "ğŸ¥" : "ğŸ§";
      
      // å®šæ•°å®šç¾©
      const CONTROL_ZONE_HEIGHT = 120;
      const BAR_MIN_WIDTH = 100, BAR_MAX_WIDTH = 300, BAR_HEIGHT = 20;
      const ENEMY_PROBABILITY = 0.3, ENEMY_SIZE = 30;
      const ITEM_SIZE = 40;
      const LIFE_ICON_SIZE = 48, LIFE_SPACING = 60;
      const BASE_SCROLL_SPEED = 1, BASE_GRAVITY = 0.3;
      const FALL_SPEED = 3;
      
      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      
      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç¾¤ã€ã‚¹ã‚³ã‚¢é–¢é€£
      let gameState = "start",
          startTime,
          score = 0,
          bonusScore = 0,
          cameraOffset = 0,
          barTransparentTimer = 0,
          bars = [],
          items = [],
          effects = [],
          nextBarY = 150,
          nextItemY = 200,
          highScore = parseInt(localStorage.getItem("highScore")) || 0;
      
      // â˜…è¿½åŠ ï¼šã‚¹ã‚³ã‚¢é–¢é€£ã®å¤‰æ•°ï¼ˆã‚³ãƒ³ãƒœç”¨ï¼‰
      let comboCount = 0;
      let lastComboTime = 0;
      const COMBO_RESET_TIME = 2000; // 2ç§’ä»¥å†…ã«æ¬¡ã®æ•µã‚’å€’ã›ã°ã‚³ãƒ³ãƒœç¶™ç¶š
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
      const player = {
         x: 0,
         y: 100,
         width: 70,
         height: 70,
         vx: 0,
         vy: 0,
         speed: 3,
         jumpStrength: -10,
         onBar: false,
         lives: 3,
         invincible: false,
         invincibleTimer: 0,
         muscleInvincible: false,
         muscleInvincibleTimer: 0
      };
      
      // ã‚­ãƒ¼å…¥åŠ›çŠ¶æ…‹ç®¡ç†
      const keys = {};
      
      // ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒªã‚µã‚¤ã‚ºå‡¦ç†
      // â€»ç”»é¢ã®ç¸¦æ¨ªæ¯”ãŒç‰¹ã«ç¸¦é•·ã®å ´åˆã¯ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ã‹ã‘ã¦ç”»é¢å…¨ä½“ã«æ‹¡å¤§è¡¨ç¤ºã™ã‚‹
      let gameAreaHeight = 0;
      const resizeCanvas = () => {
         // åŸºæœ¬ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
         const winWidth = window.innerWidth;
         const winHeight = window.innerHeight;
         
         // ç¸¦æ¨ªæ¯”ã‚’è¨ˆç®—ï¼ˆä¾‹ã¨ã—ã¦ã€ç¸¦æ¨ªæ¯”ãŒ1.8ã‚ˆã‚Šå¤§ãã„å ´åˆã«æ‹¡å¤§ç‡ã‚’ç®—å‡ºï¼‰
         const aspectRatio = winHeight / winWidth;
         let scale = 1;
         if(aspectRatio > 1.8) {
           scale = aspectRatio / 1.8;  // åŸºæº–ã¨ãªã‚‹æ¯”ç‡1.8ã¯ãŠå¥½ã¿ã§èª¿æ•´å¯èƒ½
         }
         
         // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ç‰©ç†ã‚µã‚¤ã‚ºã‚’è¨­å®š
         canvas.width = winWidth * scale;
         canvas.height = winHeight * scale;
         // æç”»æ™‚ã®åº§æ¨™è¨ˆç®—ã®ãŸã‚ã€ã“ã“ã§ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›ã‚’é©ç”¨
         ctx.setTransform(scale, 0, 0, scale, 0, 0);
         
         // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«éƒ¨åˆ†ã‚’é™¤ã„ãŸã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ã®é«˜ã•
         gameAreaHeight = canvas.height / scale - CONTROL_ZONE_HEIGHT;
      };
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      
      // ãƒªãƒã‚¸ãƒˆãƒªãƒªãƒ³ã‚¯
      const repoLink = document.getElementById("repoLink");
      
      // ã‚­ãƒ¼æ“ä½œã‚¤ãƒ™ãƒ³ãƒˆ
      document.addEventListener("keydown", (e) => {
         if(["ArrowLeft", "ArrowRight", "Space"].includes(e.code)) e.preventDefault();
         if(e.code === "Space" && (gameState === "start" || gameState === "gameover")){
             initGame();
             startBtn.style.display = "none";
             return;
         }
         keys[e.code] = true;
      });
      document.addEventListener("keyup", (e) => { keys[e.code] = false; });
      window.addEventListener("blur", () => {
         keys["ArrowLeft"] = keys["ArrowRight"] = keys["Space"] = false;
      });
      
      // ã‚¿ãƒƒãƒæ“ä½œã®çµ±ä¸€å‡¦ç†
      const handleTouch = (e) => {
         keys["ArrowLeft"] = keys["ArrowRight"] = false;
         for(let i = 0, len = e.touches.length; i < len; i++){
             const touchX = e.touches[i].clientX;
             if(touchX < window.innerWidth / 2){
               keys["ArrowLeft"] = true;
             } else {
               keys["ArrowRight"] = true;
             }
         }
      };
      const handleTouchEnd = (e) => {
         if(e.touches.length === 0){
             keys["ArrowLeft"] = keys["ArrowRight"] = false;
         } else {
             handleTouch(e);
         }
      };
      canvas.addEventListener("touchstart", handleTouch);
      canvas.addEventListener("touchmove", handleTouch);
      canvas.addEventListener("touchend", handleTouchEnd);
      
      // ã‚¸ãƒ£ãƒ³ãƒ—ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹å…±é€šï¼‰
      const jumpBtn = document.getElementById("jumpBtn");
      const jumpAction = (e) => {
         e.preventDefault();
         if(gameState === "playing" && player.onBar){
             player.vy = player.jumpStrength;
             player.onBar = false;
         }
      };
      jumpBtn.addEventListener("touchstart", jumpAction);
      jumpBtn.addEventListener("mousedown", jumpAction);
      
      // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
      const startBtn = document.getElementById("startBtn");
      startBtn.addEventListener("click", (e) => {
         e.preventDefault();
         initGame();
         startBtn.style.display = "none";
      });
      
      // ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼šä¹±æ•°ç”Ÿæˆ
      const random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      // ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼šçŸ©å½¢åŒå£«ã®å½“ãŸã‚Šåˆ¤å®š
      const rectsIntersect = (ax, ay, aw, ah, bx, by, bw, bh) =>
         ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
      
      // ãƒãƒ¼ç”Ÿæˆ
      function spawnBars() {
         while(nextBarY < cameraOffset + gameAreaHeight + 200) {
             const barWidth = random(BAR_MIN_WIDTH, BAR_MAX_WIDTH);
             const barX = random(0, canvas.width - barWidth);
             let type = "normal";
             const r = Math.random();
             if(r < 0.15) type = "green";
             else if(r < 0.30) type = "blue";
             else if(r < 0.45) type = "fading";
             
             const bar = {
               x: barX,
               y: nextBarY,
               width: barWidth,
               height: BAR_HEIGHT,
               type,
               enemy: null,
               fading: false,
               fadeTimer: 0
             };
             if(type === "blue") {
               bar.vx = (Math.random() < 0.5 ? -1 : 1) * (Math.random() + 0.5);
             }
             if(Math.random() < ENEMY_PROBABILITY) {
               const enemyX = random(barX, barX + barWidth - ENEMY_SIZE);
               bar.enemy = {
                 x: enemyX,
                 y: nextBarY - ENEMY_SIZE,
                 size: ENEMY_SIZE,
                 vx: (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.5 + 0.5)
               };
             }
             bars.push(bar);
             nextBarY += random(80,150);
         }
      }
      
      // ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆ
      function spawnItems() {
         while(nextItemY < cameraOffset + gameAreaHeight + 200) {
             const itemX = random(0, canvas.width - ITEM_SIZE);
             const r = Math.random();
             let type = (r < 0.2) ? "heart" : (r < 0.5) ? "muscle" : "cake";
             items.push({ x: itemX, y: nextItemY, size: ITEM_SIZE, type });
             nextItemY += random(200,300);
         }
      }
      
      // ã‚²ãƒ¼ãƒ æ›´æ–°å‡¦ç†
      function update() {
         if(gameState !== "playing") return;
         const elapsed = (Date.now() - startTime) / 1000;
         score = Math.floor(elapsed * 10) + bonusScore;
         if(score > highScore) {
           highScore = score;
           localStorage.setItem("highScore", highScore);
         }
         
         const currentScrollSpeed = BASE_SCROLL_SPEED + elapsed * 0.05;
         cameraOffset += currentScrollSpeed;
         const currentGravity = BASE_GRAVITY;
         
         // åˆæœŸç„¡æ•µï¼ˆæœ€åˆ2ç§’ï¼‰
         if(elapsed < 2) player.invincible = true;
         
         // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
         if(keys["ArrowLeft"]) player.x -= player.speed;
         if(keys["ArrowRight"]) player.x += player.speed;
         player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));
         if(keys["Space"] && player.onBar) {
             player.vy = player.jumpStrength;
             player.onBar = false;
         }
         player.vy += currentGravity;
         player.y += player.vy;
         
         // ãƒãƒ¼ã®æ›´æ–°ï¼ˆå·¦å³ç§»å‹•ãƒ»æ•µã®ç§»å‹•ï¼‰
         for(const bar of bars) {
             if(bar.type === "blue") {
               bar.x += bar.vx;
               if(bar.x < 0 || bar.x + bar.width > canvas.width) {
                   bar.vx = -bar.vx;
                   bar.x = Math.max(0, Math.min(bar.x, canvas.width - bar.width));
               }
             }
             if(bar.enemy) {
               if(bar.enemy.ejected) {
                   bar.enemy.x += bar.enemy.vx;
                   bar.enemy.y += bar.enemy.vy;
                   bar.enemy.vy += 0.5;
                   if(bar.enemy.y - cameraOffset > gameAreaHeight ||
                      bar.enemy.x < -50 || bar.enemy.x > canvas.width + 50) {
                       bar.enemy = null;
                   }
               } else {
                   bar.enemy.x += bar.enemy.vx;
                   if(bar.enemy.x < bar.x || bar.enemy.x + bar.enemy.size > bar.x + bar.width) {
                       bar.enemy.vx = -bar.enemy.vx;
                       bar.enemy.x = Math.max(bar.x, Math.min(bar.enemy.x, bar.x + bar.width - bar.enemy.size));
                   }
               }
             }
         }
         
         // fadingãƒãƒ¼ã®æ›´æ–°
         for(let i = bars.length - 1; i >= 0; i--) {
             const bar = bars[i];
             if(bar.fading) {
               bar.y += FALL_SPEED;
               if(--bar.fadeTimer <= 0) bars.splice(i, 1);
             }
         }
         
         // ä¸Šéƒ¨è¡çªãƒã‚§ãƒƒã‚¯
         const playerScreenY = player.y - cameraOffset;
         if(playerScreenY < 0 && barTransparentTimer <= 0) {
             if(--player.lives <= 0) gameState = "gameover";
             barTransparentTimer = 10;
             player.vy = 5;
         }
         if(barTransparentTimer > 0) barTransparentTimer--;
         
         spawnBars();
         spawnItems();
         
         // ãƒãƒ¼ã¨ã®è¡çªåˆ¤å®š
         if(barTransparentTimer <= 0) {
             player.onBar = false;
             for(const bar of bars) {
               if(player.x < bar.x + bar.width && player.x + player.width > bar.x) {
                 if(player.vy >= 0 &&
                    player.y + player.height >= bar.y &&
                    player.y + player.height <= bar.y + BAR_HEIGHT + player.vy) {
                       if(bar.type === "fading" && !bar.fading) {
                          bar.fading = true;
                          bar.fadeTimer = 60;
                       }
                       player.y = bar.y - player.height;
                       player.vy = (bar.type === "green") ? player.jumpStrength : 0;
                       player.onBar = true;
                       if(bar.type === "blue") player.x += bar.vx;
                       break;
                 }
               }
             }
         }
         
         // æ•µã¨ã®è¡çªåˆ¤å®š
         for(const bar of bars) {
             if(bar.enemy && rectsIntersect(player.x, player.y, player.width, player.height,
                                             bar.enemy.x, bar.enemy.y, bar.enemy.size, bar.enemy.size)) {
				// ä¿®æ­£å¾Œã®æ•µè¡çªå‡¦ç†éƒ¨åˆ†ï¼ˆå¤‰æ›´ç®‡æ‰€ã«â˜…ã‚’è¿½åŠ ï¼‰
				if (player.muscleInvincible) {
				  // â˜…ä¿®æ­£: æ•µã‚’å€’ã—ãŸã¨ãã®å‡¦ç†ï¼ˆã‚³ãƒ³ãƒœå‡¦ç†ï¼‰
				  if (!bar.enemy.hit) {
				    const now = Date.now();
				    // â˜…å¤‰æ›´: ãƒãƒƒã‚¹ãƒ«ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯æ™‚é–“ã«ã‚ˆã‚‹ãƒªã‚»ãƒƒãƒˆã‚’ã—ãªã„
				    if (!player.muscleInvincible && now - lastComboTime > COMBO_RESET_TIME) {
				      comboCount = 0;
				    }
				    comboCount++;
				    lastComboTime = now;
				    
				    // â˜…ä¿®æ­£: ã‚¹ã‚³ã‚¢åŠ ç®—ã‚’ã‚³ãƒ³ãƒœæ•°Ã—100ã«å¤‰æ›´
				    const comboBonus = 100 * comboCount;
				    bonusScore += comboBonus;
				    
				    effects.push({ 
				      x: bar.enemy.x + bar.enemy.size/2, 
				      y: bar.enemy.y, 
				      alpha: 1, 
				      timer: 30, 
				      text: `+${comboBonus}`,
				      comboText: comboCount > 1 ? `Combo ${comboCount}!` : null
				    });
				    
				    bar.enemy.hit = true;
				  }
                 // æ—¢å­˜ã®æ•µå¹ãé£›ã°ã—å‡¦ç†...
                 bar.enemy.vx = (Math.random() < 0.5 ? -10 : 10);
                 bar.enemy.vy = -10;
                 bar.enemy.ejected = true;
               } else if(elapsed >= 2 && !player.invincible) {
                 if(--player.lives <= 0) gameState = "gameover";
                 player.x += (Math.random() < 0.5 ? -20 : 20);
                 player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));
                 player.invincible = true;
                 player.invincibleTimer = 60;
               }
             }
         }
         
         // ã‚¢ã‚¤ãƒ†ãƒ ã¨ã®è¡çªåˆ¤å®š
         for(let i = items.length - 1; i >= 0; i--) {
           const item = items[i];
           if(rectsIntersect(player.x, player.y, player.width, player.height,
                             item.x, item.y, item.size, item.size)) {
             if(item.type === "heart") {
                 player.lives++;
                 effects.push({ x: item.x + item.size/2, y: item.y, alpha: 1, timer: 30, text: "ğŸ’–" });
             } else if(item.type === "muscle") {
                 player.muscleInvincible = true;
                 player.muscleInvincibleTimer = 600;
                 effects.push({ x: item.x + item.size/2, y: item.y, alpha: 1, timer: 30, text: "ğŸ’ª" });
             } else {
                 bonusScore += 100;
                 effects.push({ x: item.x + item.size/2, y: item.y, alpha: 1, timer: 30, text: "+100" });
             }
             items.splice(i, 1);
           }
         }
         
         // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
         for(let i = effects.length - 1; i >= 0; i--) {
             const eff = effects[i];
             if(--eff.timer <= 0) effects.splice(i, 1);
             else {
               eff.y -= 0.5;
               eff.alpha = eff.timer / 30;
             }
         }
         
         // ç„¡æ•µã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
         if(elapsed >= 2 && player.invincible && --player.invincibleTimer <= 0) {
             player.invincible = false;
         }
         // â˜…è¿½åŠ ï¼šãƒãƒƒã‚¹ãƒ«ãƒ¢ãƒ¼ãƒ‰çµ‚äº†æ™‚ã®å‡¦ç†ï¼ˆã‚³ãƒ³ãƒœãƒªã‚»ãƒƒãƒˆå«ã‚€ï¼‰
         if(player.muscleInvincible && --player.muscleInvincibleTimer <= 0) {
             player.muscleInvincible = false;
             comboCount = 0; // ã‚³ãƒ³ãƒœãƒªã‚»ãƒƒãƒˆ
             lastComboTime = 0;
         }
         
         // ä¸‹éƒ¨è¡çªåˆ¤å®š
         if(player.y - cameraOffset + player.height > gameAreaHeight) gameState = "gameover";
      }
      
      // æç”»å‡¦ç†
      function draw() {
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         ctx.fillStyle = "#87CEEB";
         ctx.fillRect(0, 0, canvas.width, canvas.height);
         
         // ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã®è¡¨ç¤º
         if(gameState === "start") {
             repoLink.style.display = "block";
             ctx.fillStyle = "white";
             ctx.textAlign = "center";
             ctx.textBaseline = "middle";
             ctx.font = "80px sans-serif";
             ctx.fillText(playerEmoji, canvas.width/2, canvas.height/2 - 150);
             ctx.font = "50px sans-serif";
             ctx.fillText("Endless fall", canvas.width/2, canvas.height/2 - 80);
             ctx.font = "30px sans-serif";
             ctx.fillText("ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‹ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§é–‹å§‹", canvas.width/2, canvas.height/4);
             startBtn.textContent = "ã‚¹ã‚¿ãƒ¼ãƒˆ";
             startBtn.style.display = "block";
             return;
         }
         repoLink.style.display = "none";
         
         // ãƒãƒ¼ãƒ»æ•µãƒ»ã‚¢ã‚¤ãƒ†ãƒ æç”»
         for(const bar of bars) {
             const barScreenY = bar.y - cameraOffset;
             if(barScreenY + bar.height >= -20 && barScreenY <= gameAreaHeight + 20) {
               const baseAlpha = (barTransparentTimer > 0 ? 0.3 : 1) * (bar.fading ? (bar.fadeTimer / 60) : 1);
               ctx.globalAlpha = baseAlpha;
               const fillColor = (bar.type === "green") ? "green" :
                                 (bar.type === "blue") ? "blue" : "#654321";
               ctx.fillStyle = fillColor;
               ctx.fillRect(bar.x, barScreenY, bar.width, BAR_HEIGHT);
               if(bar.enemy) {
                 const enemyScreenY = bar.enemy.y - cameraOffset;
                 ctx.font = `${bar.enemy.size}px sans-serif`;
                 ctx.textAlign = "center";
                 ctx.textBaseline = "middle";
                 ctx.fillText("ğŸª¼", bar.enemy.x + bar.enemy.size/2, enemyScreenY + bar.enemy.size/2);
               }
               ctx.globalAlpha = 1;
             }
         }
         // ã‚¢ã‚¤ãƒ†ãƒ æç”»
         ctx.font = "48px sans-serif";
         ctx.textAlign = "center";
         ctx.textBaseline = "middle";
         for(const item of items) {
             const itemScreenY = item.y - cameraOffset;
             if(itemScreenY > -20 && itemScreenY < gameAreaHeight + 20) {
               const emoji = (item.type === "heart") ? "ğŸ’–" :
                             (item.type === "muscle") ? "ğŸ’ª" : "ğŸ°";
               ctx.fillText(emoji, item.x + item.size/2, itemScreenY + item.size/2);
             }
         }
         // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
         const playerScreenY = player.y - cameraOffset;
         if(player.invincible) ctx.globalAlpha = 0.5;
         ctx.font = "70px sans-serif";
         ctx.textAlign = "center";
         ctx.textBaseline = "middle";
         ctx.fillText(playerEmoji, player.x + player.width/2, playerScreenY + player.height/2);
         ctx.globalAlpha = 1;
         if(player.muscleInvincible) {
             ctx.font = "50px sans-serif";
             ctx.fillText("ğŸ’ª", player.x - 10, playerScreenY + player.height/2);
         }
         // ã‚¹ã‚³ã‚¢ãƒ»ãƒã‚¤ã‚¹ã‚³ã‚¢æç”»
         ctx.fillStyle = "black";
         ctx.font = "30px sans-serif";
         ctx.textAlign = "center";
         ctx.fillText("High Score: " + highScore, canvas.width/2, 40);
         ctx.textAlign = "left";
         ctx.fillText("Score: " + score, 10, 70);
         // ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ã‚¸æç”»
         const livesCount = player.lives;
         const startX = canvas.width - (livesCount * LIFE_SPACING) - 10;
         ctx.textAlign = "center";
         ctx.textBaseline = "middle";
         for(let i = 0; i < livesCount; i++) {
             ctx.font = LIFE_ICON_SIZE + "px sans-serif";
             ctx.fillText(playerEmoji, startX + i * LIFE_SPACING + LIFE_ICON_SIZE/2, 70);
         }
         // â˜…è¿½åŠ ï¼šã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»å‡¦ç†ã®ä¿®æ­£ï¼ˆã‚³ãƒ³ãƒœãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºå«ã‚€ï¼‰
         ctx.save();
         ctx.textAlign = "center";
         ctx.textBaseline = "middle";
         for(const eff of effects) {
             ctx.globalAlpha = eff.alpha;
             ctx.font = "70px sans-serif";
             ctx.fillText(eff.text, eff.x, eff.y - cameraOffset);
             
             // ã‚³ãƒ³ãƒœãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºï¼ˆã‚³ãƒ³ãƒœæ•°ãŒ2ä»¥ä¸Šã®å ´åˆï¼‰
             if(eff.comboText) {
               ctx.font = "40px sans-serif";
               ctx.fillStyle = "gold";
               ctx.fillText(eff.comboText, eff.x, eff.y - cameraOffset - 50);
             }
         }
         ctx.restore();
         ctx.globalAlpha = 1;
         
         // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼è¡¨ç¤º
         if(gameState === "gameover") {
             ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             ctx.fillStyle = "white";
             ctx.font = "80px sans-serif";
             ctx.textAlign = "center";
             ctx.textBaseline = "middle";
             ctx.fillText("Game Over", canvas.width/2, canvas.height/3);
             startBtn.textContent = "å†ã‚¹ã‚¿ãƒ¼ãƒˆ";
             startBtn.style.display = "block";
         }
      }
      
      // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
      function gameLoop() {
         if(gameState === "playing") update();
         draw();
         requestAnimationFrame(gameLoop);
      }
      
      // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–å‡¦ç†
      function initGame() {
         gameState = "playing";
         cameraOffset = 0;
         startTime = Date.now();
         score = bonusScore = 0;
         barTransparentTimer = 0;
         effects = [];
         nextBarY = 150;
         nextItemY = 200;
         player.x = canvas.width/2 - player.width/2;
         player.y = 100;
         player.vx = player.vy = 0;
         player.onBar = false;
         player.lives = 3;
         player.invincible = false;
         player.invincibleTimer = 0;
         player.muscleInvincible = false;
         player.muscleInvincibleTimer = 0;
         bars = [];
         items = [];
         spawnBars();
         spawnItems();
      }
      
      gameState = "start";
      startBtn.style.display = "block";
      gameLoop();
      
    })();
  </script>
</body>
</html>
